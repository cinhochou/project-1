<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ymesh_object_Demo_Fixed</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #222;
      }
    </style>
  </head>
  <body>
    <div
      id="size-display"
      style="
        position: fixed;
        top: 12px;
        left: 12px;
        background: rgba(0, 0, 0, 0.65);
        color: rgb(255, 255, 255);
        font-family: 'Courier New', monospace;
        font-size: 14px;
        font-weight: bold;
        padding: 8px 12px;
        border-radius: 6px;
        border: 1px solid #0f0;
        z-index: 10000;
        user-select: none;
        pointer-events: none;
        backdrop-filter: blur(4px);
        box-shadow: 0 2px 10px rgba(0, 255, 0, 0.2);
        min-width: 180px;
        text-align: center;
        transition: all 0.2s ease;
      "
    >
      Window: <span id="size-text">0000 × 0000</span>
    </div>

    <!-- 操作提示 -->
    <div
      style="
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: #aaa;
        font-family: sans-serif;
        font-size: 12px;
        pointer-events: none;
        text-align: center;
      "
    ></div>

    <script src="bulid/three.js"></script>
    <script src="bulid/OrbitControls.js"></script>

    <script type="module">
      import * as Y from 'yjs'
      import { WebrtcProvider } from 'y-webrtc'

      const scene = new THREE.Scene()
      scene.background = new THREE.Color(0x222222)

      const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000)
      camera.position.set(6, 6, 10)

      const renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(innerWidth, innerHeight)
      renderer.setPixelRatio(devicePixelRatio)
      document.body.appendChild(renderer.domElement)

      // 将 OrbitControls 配置为只响应右键，避免与方块旋转（左键）冲突
      const controls = new THREE.OrbitControls(camera, renderer.domElement)
      controls.mouseButtons = {
        LEFT: null, // 禁用左键（留给方块旋转）
        MIDDLE: THREE.MOUSE.DOLLY,
        RIGHT: THREE.MOUSE.ROTATE, // 右键旋转相机
      }
      controls.enableZoom = false // 禁用 OrbitControls 的缩放，避免与方块缩放冲突

      const cube = new THREE.Mesh(
        new THREE.BoxGeometry(2, 2, 2),
        new THREE.MeshPhongMaterial({ color: 0x00ff88 }),
      )
      scene.add(cube)

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.5)
      dirLight.position.set(5, 10, 7)
      scene.add(dirLight)
      scene.add(new THREE.AmbientLight(0xffffff, 0.5))

      const ydoc = new Y.Doc()
      const provider = new WebrtcProvider('Y-cube-object', ydoc, {
        signaling: ['ws://localhost:4444'],
      })

      const shared = ydoc.getMap('cube')

      if (!shared.has('rotation')) shared.set('rotation', { x: 0, y: 0, z: 0 })
      if (!shared.has('scale')) shared.set('scale', { x: 1, y: 1, z: 1 })

      let last = { rot: null, scl: null }

      shared.observe(() => {
        const r = shared.get('rotation')
        const s = shared.get('scale')
        if (r) {
          cube.rotation.set(r.x, r.y, r.z)
          last.rot = { ...r }
        }
        if (s) {
          cube.scale.set(s.x, s.y, s.z)
          last.scl = { ...s }
        }
      })

      function syncObject() {
        const r = cube.rotation
        const s = cube.scale

        const rotChanged =
          !last.rot ||
          Math.abs(r.x - last.rot.x) > 1e-6 ||
          Math.abs(r.y - last.rot.y) > 1e-6 ||
          Math.abs(r.z - last.rot.z) > 1e-6
        const sclChanged =
          !last.scl ||
          Math.abs(s.x - last.scl.x) > 1e-6 ||
          Math.abs(s.y - last.scl.y) > 1e-6 ||
          Math.abs(s.z - last.scl.z) > 1e-6

        if (rotChanged || sclChanged) {
          ydoc.transact(() => {
            if (rotChanged) shared.set('rotation', { x: r.x, y: r.y, z: r.z })
            if (sclChanged) shared.set('scale', { x: s.x, y: s.y, z: s.z })
          })
          if (rotChanged) last.rot = { x: r.x, y: r.y, z: r.z }
          if (sclChanged) last.scl = { x: s.x, y: s.y, z: s.z }
        }
      }

      let isDragging = false
      let prev = { x: 0, y: 0 }

      // 定义固定的旋转灵敏度 (弧度/像素)
      // 无论屏幕多大，鼠标移动 1px 对应的旋转角度是固定的
      const ROTATION_SENSITIVITY = 0.005

      const onPointerDown = (e) => {
        if (e.button !== 0) return // 只响应左键
        isDragging = true
        prev = { x: e.clientX, y: e.clientY }
        renderer.domElement.style.cursor = 'grabbing'
      }

      const onPointerMove = (e) => {
        if (!isDragging) return

        // 计算像素差值
        const deltaX = e.clientX - prev.x
        const deltaY = e.clientY - prev.y

        // 使用固定灵敏度
        const rotateY = deltaX * ROTATION_SENSITIVITY
        const rotateX = deltaY * ROTATION_SENSITIVITY

        cube.rotation.y += rotateY
        cube.rotation.x += rotateX

        prev = { x: e.clientX, y: e.clientY }
      }

      const onPointerUp = () => {
        isDragging = false
        renderer.domElement.style.cursor = 'auto'
      }

      const onWheel = (e) => {
        e.preventDefault()
        // 保持原有的缩放逻辑，这部分其实是相对值的，只要不依赖屏幕尺寸即可
        // 稍微调整一下逻辑，使其更平滑，但保持核心一致性
        const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1

        cube.scale.multiplyScalar(scaleFactor)

        const min = 0.2,
          max = 10
        cube.scale.x = cube.scale.y = cube.scale.z = Math.max(min, Math.min(max, cube.scale.x))
      }

      renderer.domElement.addEventListener('pointerdown', onPointerDown)
      renderer.domElement.addEventListener('pointermove', onPointerMove)
      renderer.domElement.addEventListener('pointerup', onPointerUp)
      renderer.domElement.addEventListener('pointerleave', onPointerUp)
      renderer.domElement.addEventListener('wheel', onWheel, { passive: false })

      function animate() {
        requestAnimationFrame(animate)
        //controls.update()
        syncObject()
        renderer.render(scene, camera)
      }
      animate()

      // 窗口大小调整
      window.addEventListener('resize', () => {
        camera.aspect = innerWidth / innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(innerWidth, innerHeight)
        updateWindowSize()
      })

      // 尺寸显示逻辑
      const sizeText = document.getElementById('size-text')
      function updateWindowSize() {
        const w = window.innerWidth
        const h = window.innerHeight
        sizeText.textContent = `${w.toString().padStart(4)} × ${h.toString().padStart(4)}`
      }
      updateWindowSize()
    </script>
  </body>
</html>
