<!-- 描述：通过控制相机位置和轨道中心来同步物体 -->
<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ymesh_camera_Demo</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #222;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="bulid/three.js"></script>
    <script src="bulid/OrbitControls.js"></script>
    <script type="module">
      import * as Y from 'yjs'
      import { WebrtcProvider } from 'y-webrtc'

      const scene = new THREE.Scene()
      scene.background = new THREE.Color(0x222222)

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      )
      camera.position.set(4, 4, 8)

      const renderer = new THREE.WebGLRenderer({ antialias: true })
      renderer.setSize(window.innerWidth, window.innerHeight)
      renderer.setPixelRatio(window.devicePixelRatio)
      document.body.appendChild(renderer.domElement)

      const controls = new THREE.OrbitControls(camera, renderer.domElement)
      controls.enableDamping = true
      controls.dampingFactor = 0.5

      const geometry = new THREE.BoxGeometry(2, 2, 2)
      const material = new THREE.MeshPhongMaterial({ color: 0x00ff88 })
      const cube = new THREE.Mesh(geometry, material)
      scene.add(cube)

      const dirLight = new THREE.DirectionalLight(0xffffff, 1.2)
      dirLight.position.set(5, 10, 7)
      scene.add(dirLight)
      scene.add(new THREE.AmbientLight(0xffffff, 0.5))

      // Yjs 共享相机状态
      const ydoc = new Y.Doc()
      const provider = new WebrtcProvider('Y-cube', ydoc, {
        signaling: ['ws://localhost:4444'], // npx y-webrtc-signaling
      })

      const shared = ydoc.getMap('camera')

      // 初始化共享状态
      if (!shared.has('position')) shared.set('position', { x: 4, y: 4, z: 8 })
      if (!shared.has('target')) shared.set('target', { x: 0, y: 0, z: 0 })

      // 远程更新 → 本地相机
      shared.observe(() => {
        const pos = shared.get('position')
        const tgt = shared.get('target')
        if (pos) camera.position.set(pos.x, pos.y, pos.z)
        if (tgt) controls.target.set(tgt.x, tgt.y, tgt.z)
        controls.update()
      })

      // 本地 → 远程（每帧同步）
      let last = {}
      function syncCamera() {
        const pos = camera.position
        const tgt = controls.target

        const posChanged =
          !last.pos || ['x', 'y', 'z'].some((axis) => Math.abs(pos[axis] - last.pos[axis]) > 1e-6)
        const tgtChanged =
          !last.tgt || ['x', 'y', 'z'].some((axis) => Math.abs(tgt[axis] - last.tgt[axis]) > 1e-6)

        if (posChanged || tgtChanged) {
          ydoc.transact(() => {
            if (posChanged) shared.set('position', { x: pos.x, y: pos.y, z: pos.z })
            if (tgtChanged) shared.set('target', { x: tgt.x, y: tgt.y, z: tgt.z })
          })
          last.pos = { x: pos.x, y: pos.y, z: pos.z }
          last.tgt = { x: tgt.x, y: tgt.y, z: tgt.z }
        }
      }

      // 动画循环
      function animate() {
        requestAnimationFrame(animate)
        controls.update()
        syncCamera()
        renderer.render(scene, camera)
      }
      animate()

      // 自适应
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
      })
    </script>
  </body>
</html>
