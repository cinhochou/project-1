<!doctype html>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
/>
<!-- three.js library -->
<script src="bulid/three.js"></script>
<script src="bulid/stats.js"></script>
<!-- OrbitControls -->
<!-- <script>
  // 简化的非模块版本OrbitControls
  ;(function () {
    if (typeof THREE === 'undefined') return

    THREE.OrbitControls = function (object, domElement) {
      this.object = object
      this.domElement = domElement

      // 简化的控制逻辑
      this.enableDamping = true
      this.dampingFactor = 0.05

      this.update = function () {
        // 简化的更新逻辑
        if (this.enableDamping) {
          // 阻尼效果
        }
      }
    }
  })()
</script> -->
<!-- ar.js -->
<script src="bulid/ar.js"></script>
<script src="bulid/MTLLoader.js"></script>
<script src="bulid/OBJLoader.js"></script>
<script type="module">
  import ArBaseControls from './bulid/threex-arbasecontrols.js'
  window.ArBaseControls = ArBaseControls
</script>

<style></style>

<body
  style="
    margin: 0px;
    overflow: hidden;
    font-family: Monospace;
    -webkit-transform: translate3d(0, 0, 0);
  "
>
  <!-- <div style="position: absolute; top: 10px; width: 100%; text-align: center; z-index: 1">
     
    <div id="Stats-output"></div>
  </div> -->
  <script>
    // var obj
    // //fps监测
    // var stats = initStats()

    // //fps状态
    // function initStats() {
    //   var stats = new Stats()
    //   stats.setMode(0) // 0: fps, 1: ms

    //   // Align top-left
    //   stats.domElement.style.position = 'absolute'
    //   stats.domElement.style.left = '0px'
    //   stats.domElement.style.top = '0px'

    //   document.getElementById('Stats-output').appendChild(stats.domElement)
    //   return stats
    // }

    // init renderer
    var renderer = new THREE.WebGLRenderer({
      antialias: true, //开启抗锯齿
      alpha: true, //开启背景透明
    })
    renderer.setClearColor(new THREE.Color('lightgrey'), 0)
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.domElement.style.position = 'absolute'
    renderer.domElement.style.top = '0px'
    renderer.domElement.style.left = '0px'
    document.body.appendChild(renderer.domElement)

    // array of functions for the rendering loop 呈现循环的函数数组
    var onRenderFcts = []

    // 初始化场景和摄像机
    var scene = new THREE.Scene()
    var light = new THREE.DirectionalLight(0xffffff, 1.0)

    //位置不同，方向光作用于物体的面也不同，看到的物体各个面的颜色也不同
    //light.position.set(0,1,0.5 ).normalize();
    light.position.set(0, 30, 40)
    light.castShadow = true // 启用阴影选项
    scene.add(light)

    //环境光设置
    var ambilight = new THREE.AmbientLight(0xffffff, 0.2)
    scene.add(ambilight)

    // 初始化摄像机位置(0，0，0)
    camera = new THREE.Camera()
    scene.add(camera)
    // const controls = new THREE.OrbitControls(camera, renderer.domElement)
    // controls.enableDamping = true // 启用阻尼效果
    // controls.dampingFactor = 0.05 // 阻尼系数

    // handle arToolkitSource
    var arToolkitSource = new THREEx.ArToolkitSource({})
    arToolkitSource.init(function onReady() {
      onResize()
    })

    // handle resize
    window.addEventListener('resize', function () {
      onResize()
    })
    function onResize() {
      arToolkitSource.onResize()
      arToolkitSource.copySizeTo(renderer.domElement)
      if (arToolkitContext.arController !== null) {
        arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
      }
    }

    //initialize arToolkitContext

    // create atToolkitContext
    var arToolkitContext = new THREEx.ArToolkitContext({
      cameraParametersUrl: 'data/camera_para.dat',
      detectionMode: 'mono',
    })

    // initialize it
    arToolkitContext.init(function onCompleted() {
      // copy projection matrix to camera
      camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix())
    })

    // update artoolkit on every frame
    onRenderFcts.push(function () {
      if (arToolkitSource.ready === false) return

      arToolkitContext.update(arToolkitSource.domElement)

      // update scene.visible if the marker is seen
      scene.visible = camera.visible
    })
    // init controls for camera
    var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
      type: 'pattern',
      patternUrl: 'arcode/marker89.td',
      // patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.kanji',
      // as we controls the camera, set changeMatrixMode: 'cameraTransformMatrix'
      changeMatrixMode: 'cameraTransformMatrix',
      maxDetectionRate: 60, // 限制检测帧率
    })
    scene.visible = false

    onRenderFcts.push(function (delta) {
      //            if(obj)
      //			{
      //			    obj.rotation.y=+1;
      //			}
    })

    //render the whole thing on the page

    // render the scene
    onRenderFcts.push(function () {
      renderer.render(scene, camera)
    })

    // run the rendering loop
    var lastTimeMsec = null
    requestAnimationFrame(function animate(nowMsec) {
      // keep looping
      requestAnimationFrame(animate)
      // controls.update()
      //        stats.update();
      // measure time
      lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
      var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
      lastTimeMsec = nowMsec
      // call each update function
      onRenderFcts.forEach(function (onRenderFct) {
        onRenderFct(deltaMsec / 1000, nowMsec / 1000)
      })
    })

    var onProgress = function (xhr) {
      if (xhr.lengthComputable) {
        var percentComplete = (xhr.loaded / xhr.total) * 100

        console.log(Math.round(percentComplete, 2) + '% downloaded')
      }
    }

    var onError = function (xhr) {}
    var mesh = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshBasicMaterial({ color: 'red' }),
    )
    scene.add(mesh)

    // var mtlLoader = new THREE.MTLLoader()

    // mtlLoader.setPath('obj/')

    // mtlLoader.load('jj.mtl', function (materials) {
    //   materials.preload()

    //   var objLoader = new THREE.OBJLoader()

    //   objLoader.setMaterials(materials)

    //   objLoader.setPath('obj/')

    //   objLoader.load(
    //     'jj.obj',
    //     function (object) {
    //       obj = object
    //       scene.add(object)
    //       object.position.set(0, 0, 0)
    //       // 保存原始缩放值
    //       object.userData.originalScale = object.scale.clone()
    //       object.scale.set(0.0001, 0.0001, 0.0001)
    //       var axes = new THREE.AxisHelper(10)
    //       scene.add(axes)
    //     },
    //     onProgress,
    //     onError,
    //   )
    // })
    let initialTouches = null
    let initialScale = 1
    let initialRotation = 0
    let isSingleTouch = false
    let previousTouchPosition = null

    function handleTouchStart(e) {
      if (e.touches.length === 2) {
        // 双指触摸处理
        isSingleTouch = false
        initialTouches = [
          { x: e.touches[0].clientX, y: e.touches[0].clientY },
          { x: e.touches[1].clientX, y: e.touches[1].clientY },
        ]
        const dx = initialTouches[1].x - initialTouches[0].x
        const dy = initialTouches[1].y - initialTouches[0].y
        initialScale = Math.sqrt(dx * dx + dy * dy)
        initialRotation = Math.atan2(dy, dx)
      } else if (e.touches.length === 1) {
        // 单指触摸处理
        isSingleTouch = true
        previousTouchPosition = {
          x: e.touches[0].clientX,
          y: e.touches[0].clientY,
        }
      }
    }

    function handleTouchMove(e) {
      e.preventDefault() // 防止页面滚动

      if (e.touches.length === 2 && initialTouches && obj) {
        // 双指处理：缩放和旋转
        const currentTouches = [
          { x: e.touches[0].clientX, y: e.touches[0].clientY },
          { x: e.touches[1].clientX, y: e.touches[1].clientY },
        ]

        // 计算当前距离和角度
        const dx = currentTouches[1].x - currentTouches[0].x
        const dy = currentTouches[1].y - currentTouches[0].y
        const currentScale = Math.sqrt(dx * dx + dy * dy)
        const currentRotation = Math.atan2(dy, dx)

        // 处理缩放
        if (currentScale > 0 && initialScale > 0) {
          const scaleChange = currentScale / initialScale

          // 限制缩放范围，防止模型过大或过小
          const minScale = 0.00001
          const maxScale = 0.001
          const newScaleX = obj.scale.x * scaleChange
          const newScaleY = obj.scale.y * scaleChange
          const newScaleZ = obj.scale.z * scaleChange

          if (newScaleX >= minScale && newScaleX <= maxScale) {
            obj.scale.set(newScaleX, newScaleY, newScaleZ)
          }

          // 更新初始值以支持连续缩放
          initialScale = currentScale
        }

        // 处理旋转
        const rotationDelta = currentRotation - initialRotation
        obj.rotation.y += rotationDelta

        // 更新初始旋转值以支持连续旋转
        initialRotation = currentRotation
      } else if (e.touches.length === 1 && isSingleTouch && obj && previousTouchPosition) {
        // 单指处理：旋转模型
        const currentTouch = {
          x: e.touches[0].clientX,
          y: e.touches[0].clientY,
        }

        // 计算移动差值
        const deltaX = currentTouch.x - previousTouchPosition.x
        const deltaY = currentTouch.y - previousTouchPosition.y

        // 根据水平移动旋转模型（调整系数以改变灵敏度）
        obj.rotation.y += deltaX * 0.01
        obj.rotation.x += deltaY * 0.01

        // 更新位置
        previousTouchPosition = currentTouch
      }
    }

    // 修改handleTouchMove函数中的obj为mesh
    function handleMeshTouchMove(e) {
      e.preventDefault() // 防止页面滚动
      if (e.touches.length === 2 && initialTouches && mesh) {
        // 双指处理：缩放和旋转
        const currentTouches = [
          { x: e.touches[0].clientX, y: e.touches[0].clientY },
          { x: e.touches[1].clientX, y: e.touches[1].clientY },
        ]

        // 计算当前距离和角度
        const dx = currentTouches[1].x - currentTouches[0].x
        const dy = currentTouches[1].y - currentTouches[0].y
        const currentScale = Math.sqrt(dx * dx + dy * dy)
        const currentRotation = Math.atan2(dy, dx)

        // 处理缩放
        if (currentScale > 0 && initialScale > 0) {
          const scaleChange = currentScale / initialScale

          // 限制缩放范围，防止模型过大或过小
          const minScale = 0.001
          const maxScale = 5
          const newScaleX = mesh.scale.x * scaleChange
          const newScaleY = mesh.scale.y * scaleChange
          const newScaleZ = mesh.scale.z * scaleChange

          if (newScaleX >= minScale && newScaleX <= maxScale) {
            mesh.scale.set(newScaleX, newScaleY, newScaleZ)
          }

          // 更新初始值以支持连续缩放
          initialScale = currentScale
        }

        // 处理旋转
        const rotationDelta = currentRotation - initialRotation
        mesh.rotation.y += rotationDelta

        // 更新初始旋转值以支持连续旋转
        initialRotation = currentRotation
      } else if (e.touches.length === 1 && isSingleTouch && mesh && previousTouchPosition) {
        // 单指处理：旋转模型
        const currentTouch = {
          x: e.touches[0].clientX,
          y: e.touches[0].clientY,
        }

        // 计算移动差值
        const deltaX = currentTouch.x - previousTouchPosition.x
        const deltaY = currentTouch.y - previousTouchPosition.y

        // 根据水平移动旋转模型（调整系数以改变灵敏度）
        mesh.rotation.y += deltaX * 0.01
        mesh.rotation.x += deltaY * 0.01

        // 更新位置
        previousTouchPosition = currentTouch
      }
    }
    // 添加触摸事件监听器
    document.addEventListener('touchstart', handleTouchStart, { passive: false })
    //document.addEventListener('touchmove', handleTouchMove, { passive: false })
    document.addEventListener('touchmove', handleMeshTouchMove, { passive: false })
  </script>
</body>
