<!doctype html>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
/>
<!-- three.js library -->
<script src="bulid/three.js"></script>
<!-- ar.js -->
<script src="bulid/ar.js"></script>
<script src="bulid/MTLLoader.js"></script>
<script src="bulid/OBJLoader.js"></script>
<script type="module">
  import ArBaseControls from './bulid/threex-arbasecontrols.js'
  window.ArBaseControls = ArBaseControls
</script>

<style></style>

<body
  style="
    margin: 0px;
    overflow: hidden;
    font-family: Monospace;
    -webkit-transform: translate3d(0, 0, 0);
  "
>
  <div style="position: absolute; top: 10px; width: 100%; text-align: center; z-index: 1">
    <div id="position-output"></div>
  </div>
  <script type="module">
    import * as Y from 'yjs'
    import { WebrtcProvider } from 'y-webrtc'
    // init renderer
    var renderer = new THREE.WebGLRenderer({
      antialias: true, //开启抗锯齿
      alpha: true, //开启背景透明
    })
    renderer.setClearColor(new THREE.Color('lightgrey'), 0)
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.setPixelRatio(window.devicePixelRatio)
    renderer.domElement.style.position = 'absolute'
    renderer.domElement.style.top = '0px'
    renderer.domElement.style.left = '0px'
    document.body.appendChild(renderer.domElement)

    // array of functions for the rendering loop 呈现循环的函数数组
    var onRenderFcts = []

    // 初始化场景和摄像机
    var scene = new THREE.Scene()
    var light = new THREE.DirectionalLight(0xffffff, 1.0)

    light.position.set(0, 30, 40)
    light.castShadow = true // 启用阴影选项
    scene.add(light)

    // 添加辅助光源
    var backLight = new THREE.DirectionalLight(0xffffff, 0.5)
    backLight.position.set(0, 10, -20)
    scene.add(backLight)

    //环境光设置
    var ambilight = new THREE.AmbientLight(0x666666)
    scene.add(ambilight)

    // 初始化摄像机位置(0，0，0)
    var camera = new THREE.Camera()
    scene.add(camera)

    // handle arToolkitSource
    var arToolkitSource = new THREEx.ArToolkitSource({})
    arToolkitSource.init(function onReady() {
      onResize()
    })

    // handle resize
    window.addEventListener('resize', function () {
      onResize()
    })
    function onResize() {
      arToolkitSource.onResize()
      arToolkitSource.copySizeTo(renderer.domElement)
      if (arToolkitContext.arController !== null) {
        arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
      }
    }

    //initialize arToolkitContext

    // create atToolkitContext
    var arToolkitContext = new THREEx.ArToolkitContext({
      cameraParametersUrl: 'data/camera_para.dat',
      detectionMode: 'mono',
    })

    // initialize it
    arToolkitContext.init(function onCompleted() {
      // copy projection matrix to camera
      camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix())
    })

    // update artoolkit on every frame
    onRenderFcts.push(function () {
      if (arToolkitSource.ready === false) return

      arToolkitContext.update(arToolkitSource.domElement)

      // update scene.visible if the marker is seen
      scene.visible = camera.visible
    })
    // init controls for camera
    var markerControls = new THREEx.ArMarkerControls(arToolkitContext, camera, {
      type: 'pattern',
      patternUrl: 'arcode/marker89.td',
      // patternUrl : THREEx.ArToolkitContext.baseURL + '../data/data/patt.kanji',
      // as we controls the camera, set changeMatrixMode: 'cameraTransformMatrix'
      changeMatrixMode: 'cameraTransformMatrix',
      maxDetectionRate: 60, // 限制检测帧率
    })
    scene.visible = false

    // render the scene
    onRenderFcts.push(function () {
      renderer.render(scene, camera)
    })

    function getDetailedDirection(horizontalAngle, verticalAngle) {
      let description = ''

      // 水平方向（8个主要方位）
      if (horizontalAngle >= -22.5 && horizontalAngle < 22.5) {
        description += '正北'
      } else if (horizontalAngle >= 22.5 && horizontalAngle < 67.5) {
        description += '东北'
      } else if (horizontalAngle >= 67.5 && horizontalAngle < 112.5) {
        description += '正东'
      } else if (horizontalAngle >= 112.5 && horizontalAngle < 157.5) {
        description += '东南'
      } else if (horizontalAngle >= 157.5 || horizontalAngle < -157.5) {
        description += '正南'
      } else if (horizontalAngle >= -157.5 && horizontalAngle < -112.5) {
        description += '西南'
      } else if (horizontalAngle >= -112.5 && horizontalAngle < -67.5) {
        description += '正西'
      } else {
        description += '西北'
      }

      // 垂直方向
      if (verticalAngle > 30) {
        description += '上方'
      } else if (verticalAngle < -30) {
        description += '下方'
      }
      // 接近水平时不需要特别标注

      return description
    }

    // 计算相机到标记的距离
    function getDistanceDescription(distance) {
      if (distance < 1) {
        return '很近'
      } else if (distance < 3) {
        return '较近'
      } else if (distance < 6) {
        return '中等距离'
      } else {
        return '较远'
      }
    }

    // 在渲染循环中添加方位描述
    onRenderFcts.push(function () {
      if (scene.visible) {
        var cameraPosition = new THREE.Vector3()
        camera.getWorldPosition(cameraPosition)

        var horizontalAngle = (Math.atan2(cameraPosition.x, cameraPosition.z) * 180) / Math.PI
        var distanceXY = Math.sqrt(
          cameraPosition.x * cameraPosition.x + cameraPosition.z * cameraPosition.z,
        )
        var verticalAngle = (Math.atan2(cameraPosition.y, distanceXY) * 180) / Math.PI
        var distance = cameraPosition.length()

        var direction = getDetailedDirection(horizontalAngle, verticalAngle)
        var distanceDesc = getDistanceDescription(distance)
        var description = `相机位于标记${direction}方向，${distanceDesc}，水平角度${Math.round(horizontalAngle)}°，垂直角度${Math.round(verticalAngle)}°`
        console.log(description)
        document.querySelector('#position-output').textContent = description
      } else {
        document.querySelector('#position-output').textContent = ''
      }
    })

    // run the rendering loop
    var lastTimeMsec = null
    requestAnimationFrame(function animate(nowMsec) {
      // keep looping
      requestAnimationFrame(animate)
      // measure time
      lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60
      var deltaMsec = Math.min(200, nowMsec - lastTimeMsec)
      lastTimeMsec = nowMsec
      // call each update function
      onRenderFcts.forEach(function (onRenderFct) {
        onRenderFct(deltaMsec / 1000, nowMsec / 1000)
      })
    })

    var onProgress = function (xhr) {
      if (xhr.lengthComputable) {
        var percentComplete = (xhr.loaded / xhr.total) * 100

        console.log(Math.round(percentComplete, 2) + '% downloaded')
      }
    }

    var onError = function (xhr) {}
    var mesh = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshStandardMaterial({ color: 'red', metalness: 0.1, roughness: 0.5 }),
    )
    mesh.castShadow = true
    scene.add(mesh)

    // var mtlLoader = new THREE.MTLLoader()

    // mtlLoader.setPath('obj/')

    // mtlLoader.load('jj.mtl', function (materials) {
    //   materials.preload()

    //   var objLoader = new THREE.OBJLoader()

    //   objLoader.setMaterials(materials)

    //   objLoader.setPath('obj/')

    //   objLoader.load(
    //     'jj.obj',
    //     function (object) {
    //       obj = object
    //       scene.add(object)
    //       object.position.set(0, 0, 0)
    //       // 保存原始缩放值
    //       object.userData.originalScale = object.scale.clone()
    //       object.scale.set(0.0001, 0.0001, 0.0001)
    //       var axes = new THREE.AxisHelper(10)
    //       scene.add(axes)
    //     },
    //     onProgress,
    //     onError,
    //   )
    // })
    let initialTouches = null
    let initialScale = 1
    let initialRotation = 0
    let isSingleTouch = false
    let previousTouchPosition = null
    let targetObject = mesh // 默认操控 mesh 对象，可根据需要更改为 obj

    function handleTouchStart(e) {
      if (e.touches.length === 2) {
        // 双指触摸处理
        isSingleTouch = false
        initialTouches = [
          { x: e.touches[0].clientX, y: e.touches[0].clientY },
          { x: e.touches[1].clientX, y: e.touches[1].clientY },
        ]
        const dx = initialTouches[1].x - initialTouches[0].x
        const dy = initialTouches[1].y - initialTouches[0].y
        initialScale = Math.sqrt(dx * dx + dy * dy)
        initialRotation = Math.atan2(dy, dx)
      } else if (e.touches.length === 1) {
        // 单指触摸处理
        isSingleTouch = true
        previousTouchPosition = {
          x: e.touches[0].clientX,
          y: e.touches[0].clientY,
        }
      }
    }

    function handleTouchMove(e) {
      e.preventDefault() // 防止页面滚动

      // 确保目标对象存在
      if (!targetObject) return

      if (e.touches.length === 2 && initialTouches) {
        // 双指处理：只处理缩放
        const currentTouches = [
          { x: e.touches[0].clientX, y: e.touches[0].clientY },
          { x: e.touches[1].clientX, y: e.touches[1].clientY },
        ]

        // 计算当前距离
        const dx = currentTouches[1].x - currentTouches[0].x
        const dy = currentTouches[1].y - currentTouches[0].y
        const currentScale = Math.sqrt(dx * dx + dy * dy)

        // 处理缩放
        if (currentScale > 0 && initialScale > 0) {
          const scaleChange = currentScale / initialScale

          // 限制缩放范围，防止模型过大或过小
          const minScale = 0.1
          const maxScale = 5
          const newScaleX = targetObject.scale.x * scaleChange
          const newScaleY = targetObject.scale.y * scaleChange
          const newScaleZ = targetObject.scale.z * scaleChange

          if (newScaleX >= minScale && newScaleX <= maxScale) {
            targetObject.scale.set(newScaleX, newScaleY, newScaleZ)
          }

          // 更新初始值以支持连续缩放
          initialScale = currentScale
          writeToYjs()
        }
      } else if (e.touches.length === 1 && isSingleTouch && previousTouchPosition) {
        // 单指处理：只处理旋转
        const currentTouch = {
          x: e.touches[0].clientX,
          y: e.touches[0].clientY,
        }

        // 计算移动差值
        const deltaX = currentTouch.x - previousTouchPosition.x
        const deltaY = currentTouch.y - previousTouchPosition.y

        // 根据水平和垂直移动旋转模型（调整系数以改变灵敏度）
        targetObject.rotation.y += deltaX * 0.01
        targetObject.rotation.x += deltaY * 0.01

        // 更新位置
        previousTouchPosition = currentTouch
        writeToYjs()
      }
    }

    // 添加触摸事件监听器
    document.addEventListener('touchstart', handleTouchStart, { passive: false })
    document.addEventListener('touchmove', handleTouchMove, { passive: false })
    let ydoc = null
    let provider = null
    let meshMap = null
    let isApplyingRemote = false // 防止回路
    function writeToYjs() {
      if (!meshMap || isApplyingRemote) return

      const rot = {
        x: mesh.rotation.x,
        y: mesh.rotation.y,
        z: mesh.rotation.z,
      }
      const scl = mesh.scale.x

      meshMap.set('rotation', rot)
      meshMap.set('scale', scl)
    }

    function setupMeshObserver() {
      if (!meshMap) return

      meshMap.observe((event) => {
        // event.changes.keys gives changed keys; we'll read current values
        // To avoid echo loops, we set a guard flag while applying remote updates
        isApplyingRemote = true
        try {
          const rot = meshMap.get('rotation')
          const scl = meshMap.get('scale')

          if (rot && typeof rot.x === 'number') {
            mesh.rotation.set(rot.x, rot.y, rot.z)
          }
          if (typeof scl === 'number') {
            mesh.scale.set(scl, scl, scl)
          }
        } finally {
          // small timeout to ensure local write events don't race; not strictly necessary
          setTimeout(() => (isApplyingRemote = false), 0)
        }
      })
    }
    const room = 'meshRoom'
    ydoc = new Y.Doc()
    provider = new WebrtcProvider(room, ydoc, { signaling: ['ws://localhost:4444'] })
    provider.on('status', (event) => {
      console.log('WebRTC 状态:', event.connected ? '已连接' : '已断开')
    })

    provider.on('synced', () => {
      console.log('Yjs 文档同步完成')
    })

    provider.on('peers', ({ webrtcPeers, bcPeers }) => {
      const total = webrtcPeers.length + bcPeers.length
      console.log('在线 peers（含自己）:', total + 1)
    })

    meshMap = ydoc.getMap('mesh')
    if (!meshMap.has('rotation') || !meshMap.has('scale')) {
      ydoc.transact(() => {
        meshMap.set('rotation', {
          x: mesh.rotation.x,
          y: mesh.rotation.y,
          z: mesh.rotation.z,
        })
        meshMap.set('scale', mesh.scale.x)
      })
    } else {
      // 如果已有远端数据，应用到本地 mesh
      const rot = meshMap.get('rotation')
      const scl = meshMap.get('scale')
      if (rot) mesh.rotation.set(rot.x, rot.y, rot.z)
      if (typeof scl === 'number') mesh.scale.set(scl, scl, scl)
    }
    setupMeshObserver()
  </script>
</body>
<!-- 部分代码来自https://github.com/webglzhang/WebARDemo和https://github.com/AR-js-org/AR.js -->
